import { ticks } from "d3-array";
import { format } from "d3-format";
import { DateTime } from "luxon";

const WATER_DATA_DEFAULT_TICK_COUNT = 5;
const MAX_WATER_DEFAULT_TICK_COUNT = 12;

/*
 * Return ticks between startDateTime and endDateTime where the tick marks are interval apart and
 * start at startOffset
 * @param {DateTime} startDateTime
 * @param {DateTime} endDateTime
 * @param {Object} interval - a Luxon object that can be used in the .plus method to set the length between tick marks
 * @param {Object} startOffset - a Luxon object than can be used in the .plus method to set where the first tick mark begins
 * @return {Array of Number} - tick marks in dateTime format.
 */
const getTimeTicks = function (
  startDateTime,
  endDateTime,
  interval,
  startOffset,
) {
  let dateTime;
  const startOffsetKind = Object.keys(startOffset)[0];
  if (startOffsetKind === "years") {
    dateTime = startDateTime.startOf("year");
  } else if (startOffsetKind === "months") {
    dateTime = startDateTime.startOf("month");
  } else {
    dateTime = startDateTime.startOf("day");
  }
  dateTime = dateTime.plus(startOffset);

  let result = [];
  while (dateTime < endDateTime) {
    result.push(dateTime);
    dateTime = dateTime.plus(interval);
  }
  return result;
};

/*
 * Generate the values for ticks to place on a time series graph along with an appropriate format function
 * that can be used to produce a string representing the tick value. This should be used for time series that have
 * minute accuracy.
 *
 * @param startDateTimeRaw - start datetime in the form of a d3 JavaScript date
 * @param endDateTimeRaw - end datetime in the form of a d3 JavaScript date
 * @returns {Object} with two properties, dates {Array of Number timestamp in milliseconds} and
 *      format {String} the format that should be used  to display the dates.
 */
export const generateTimeTicks = function (
  startDateTimeRaw,
  endDateTimeRaw
) {
  const startDateTime = DateTime.fromJSDate(startDateTimeRaw)
  const endDateTime = DateTime.fromJSDate(endDateTimeRaw)

  /*
   * Returns a function that takes dateTime parameters and returns a string that using format to generate the string.
   */
  const formatFnc = (format) => {
    return function (dateTime) {
      return dateTime.toFormat(
        format,
      );
    };
  };

  let result = {
    dates: [],
    format: {},
  };

  //Tick marks
  result = {
    dates: getTimeTicks(
      startDateTime,
      endDateTime,
      { weeks: 4 },
      { days: 3 },
    ),
    formatWithYear: formatFnc("M/d/yy"),
    formatWithoutYear: formatFnc("M/d")
  };

  return result;
};

/*
 * This function will generate an array of tick values between nearestToZero and yDomainStart.
 * It is designed to add additional tick marks between the last tick mark generated by the standard
 * D3 tick function and the start of the yDomain. If using this on ranges that include zero, use the
 * function twice, once for the negative numbers and once for the positive tick numbers and set yDomainStart
 * to zero.
 * @param {Number} nearestToZero
 * @param {Number} yDomainStart
 * @return {Array of Number}
 */
const generateAdditionalLogTickValues = function (nearestToZero, yDomainStart) {
  let result = [];
  let nextTick = nearestToZero;
  while (nextTick > 2 && nextTick > yDomainStart) {
    nextTick = Math.ceil(nextTick / 2);
    result.push(nextTick);
  }
  return result;
};

/*
 * This function is used to round a tickValue to the nearest power of 10 if tick is above 100,
 * if the tick is between 100 and 20, round to the nearest multiple of 10, and if between 2 and 20
 * to the nearest multiple of 2. This is used to round tick marks calculated by the generatedAdditionalLogTickValues
 * for display that is suitable for log scales.
 * @param {Number} tickValue
 * @return Number
 */
const getRoundedLogTickValue = function (tickValue) {
  let roundingFactor = 1;
  const absTickValue = Math.abs(tickValue);
  if (absTickValue > 100) {
    roundingFactor = Math.pow(10, Math.floor(Math.log10(absTickValue)));
  } else if (absTickValue > 20) {
    roundingFactor = 10;
  } else if (absTickValue > 2) {
    roundingFactor = 2;
  }
  return Math.ceil(tickValue / roundingFactor) * roundingFactor;
};

/*
 * Returns an Object which contains three properties, one for an array of tick marks for the domain, one for a format function
 * suitable for displaying the tick marks, and maxTickLabelLength which contains the maximum number of characters needed
 * to display the tick marks. If useSymlog is true, tick marks suitable for
 * a symlog scale will be generated. If reverseRange is true, the tick marks are returned in reverse order
 * @param {Array of Number} domain - should be a two element array
 * @param {Boolean} useSymlog
 * @param {Boolean} reverseRange
 */
export const getWaterDataTicks = function (domain, useSymlog, reverseRange) {
  let tickValues = ticks(domain[0], domain[1], WATER_DATA_DEFAULT_TICK_COUNT);
  let tickFormat;
  if (useSymlog) {
    // For large magnitudes on log scales, the ticks can end up too close together to be
    // legible on the graph. This code generates additional tick marks by dividing up the range
    // between the tick mark closest to zero. If the domain is from negative to positive, the ticks
    // should be generated for the positive and negative domains separately.
    if (domain[0] > 0) {
      tickValues = [
        ...tickValues,
        ...generateAdditionalLogTickValues(tickValues[0], domain[0]),
      ];
    } else if (domain[1] < 0) {
      const additionalTicks = generateAdditionalLogTickValues(
        Math.abs(tickValues[0]),
        Math.abs(domain[1]),
      ).map((value) => -value);
      tickValues = [...tickValues, ...additionalTicks];
    } else {
      const positiveTickClosestToZero = tickValues.filter(
        (value) => value > 0,
      )[0];
      const negativeTickClosestToZero = tickValues
        .filter((value) => value < 0)
        .slice(-1);
      tickValues = [
        ...tickValues,
        ...generateAdditionalLogTickValues(positiveTickClosestToZero, 0),
        ...generateAdditionalLogTickValues(-negativeTickClosestToZero, 0).map(
          (value) => -value,
        ),
      ];
    }
    tickValues = tickValues.sort((a, b) => a - b);
    // Remove ticks if there are too many
    while (tickValues.length > MAX_WATER_DEFAULT_TICK_COUNT) {
      tickValues = tickValues.filter((_, index) => index % 2);
    }
    let roundedTickValues = tickValues.map(getRoundedLogTickValue);
    roundedTickValues = [...new Set(roundedTickValues)].filter(
      (value) => value > domain[0] && value < domain[1],
    );
    if (roundedTickValues.length > 1) {
      tickValues = roundedTickValues;
    } else {
      tickValues.filter((value) => value > domain[0] && value < domain[1]);
    }
  }

  // Determine the best format to use based on the tickValues generated.
  if (tickValues.find((value) => !Number.isInteger(value))) {
    let digits = 2;
    if (tickValues.length > 1) {
      digits = Math.ceil(
        Math.abs(
          Math.log10(
            (tickValues[tickValues.length - 1] - tickValues[0]) /
              tickValues.length,
          ),
        ),
      );
      tickFormat = format(`,.${digits}f`);
    } else {
      tickFormat = format(",.2f");
    }
  } else {
    tickFormat = format(",d");
  }
  const tickLengths = tickValues.map((value) => tickFormat(value).length);
  return {
    tickValues: reverseRange ? tickValues.reverse() : tickValues,
    tickFormat: tickFormat,
    maxTickLabelLength: Math.max(...tickLengths),
  };
};
